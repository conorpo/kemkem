//! The main API functions which implement ML-KEM.KeyGen, ML-KEM.Encaps, and ML-KEM.Decaps


use bitvec::view::BitView;

use crate::kpke;
use kpke::{
    KpkeKeyGenOutput,
    KpkeEncryptionKey,
    KpkeDecryptionKey
};

use crate::params::*;
use crate::crypt;
use crate::ring::*;
use crate::serialize::*;

/// Encapsulation Key generated by ML-KEM.KeyGen
/// 
/// Expects a const generic parameter to be provided, **`K`**, which should come from the respect value in the MlKemParams trait: `PARAMS::K` where PARAMS is whatever ML-KEM parameter set you are using (or its generic)
pub type MlKemEncapsulationKey<const K: usize> = KpkeEncryptionKey<K>;

/// Decapsulation Key generated by ML-KEM.KeyGen
/// 
/// Expects a const generic parameter to be provided, **`K`**, which should come from the respect value in the MlKemParams trait: `PARAMS::K` where PARAMS is whatever ML-KEM parameter set you are using (or its generic)
pub type MlKemDecapsulationKey<const K: usize> = (KpkeDecryptionKey<K>, KpkeEncryptionKey<K>, [u8; 32], [u8; 32]);

/// # ML-KEM.KeyGen 
/// 
/// Expects a generic parameter to be provided, **`PARAMS`**, the ML-KEM parameters which should implement the trait [MlKemParams]
/// 
/// **Returns** a tuple containing the ML-KEM encapsulation key and the ML-KEM decapsulation key 
/// 
pub fn key_gen<PARAMS: MlKemParams> () -> (MlKemEncapsulationKey<{PARAMS::K}>, MlKemDecapsulationKey<{PARAMS::K}>) where
    [(); 768 * PARAMS::K + 96]: ,
    [(); PARAMS::ETA_1]: ,
    [(); PARAMS::ETA_2]: ,
    [(); 64 * PARAMS::ETA_1]: ,
    [(); 384 * PARAMS::K + 32]: ,
    [(); 32 * (PARAMS::D_U * PARAMS::K + PARAMS::D_V)]: ,
{
    let z = crypt::random_bytes::<32>();

    //Encryption key, Decryption key
    let (ek, dk) : KpkeKeyGenOutput<{PARAMS::K}> = kpke::key_gen::<PARAMS>();
    
    // Encapsulation key is the encryption key
    let encapsulation_key: MlKemEncapsulationKey<{PARAMS::K}> = ek;

    let hash = crypt::h(&encapsulation_key.serialize().into_vec());

    // Fujisaki-Okamoto transformation, turn decryption key into decapsulation
    let decapsulation_key: MlKemDecapsulationKey<{PARAMS::K}> = (dk, encapsulation_key.clone(), hash, z);
    
    (encapsulation_key, decapsulation_key)
}
/// Cyphertext generated by ML-KEM.Encaps
/// 
/// Expects 3 const generic parameters which determine the size of the ring vectors, and the compression factor for the 2 main cyphertext components. These parameters should coincide with their respective values in the MlKemParams trait: `PARAMS::K`, `PARAMS::D_U`, `PARAMS::D_V` where PARAMS is whatever ML-KEM parameter set you are using (or its generic)
pub type MlKemCyphertext<const K: usize, const D_U: usize, const D_V: usize> = kpke::Cyphertext<K, D_U, D_V>;
                                                                               //  Shared Key

/// # ML-KEM.Encaps
/// 
/// Expects a generic parameter to be provided, **`PARAMS`**, the ML-KEM parameters which should implement the trait [MlKemParams]
/// 
/// Takes in the public encapsulation key as input, this ek_mlkem is expected to already be deserialized and match the type signature of [MlKemEncapsulationKey]
/// 
/// **Returns** a tuple containing the shared key (Party B's copy) and the cyphertext to be sent back
/// 
pub fn encaps<PARAMS: MlKemParams>(ek_mlkem: MlKemEncapsulationKey<{PARAMS::K}>) -> ([u8;32], MlKemCyphertext<{PARAMS::K}, {PARAMS::D_U}, {PARAMS::D_V}>) where
    [(); 768 * PARAMS::K + 96]: ,
    [(); PARAMS::K]: ,
    [(); 384 * PARAMS::K + 32]: ,
    [(); 32*(PARAMS::D_U * PARAMS::K + PARAMS::D_V)]: ,
    [(); 64 * PARAMS::ETA_1]: ,
    [(); 64 * PARAMS::ETA_2]: 
{
    let m = crypt::random_bytes::<32>();

    let ek_hash = crypt::h(&ek_mlkem.serialize().into_vec());

    let mut combined = [0u8; 64];

    combined[..32].copy_from_slice(&m);
    combined[32..].copy_from_slice(&ek_hash);

    let (key, r) = crypt::g::<64>(&combined);
    
    let m: Compressed<1, Ring> = Compressed::<1, Ring>::deserialize(&m.view_bits::<BitOrder>().to_bitvec());

    // Encrypt the encapsulation key
    let c = kpke::encrypt::<PARAMS>(ek_mlkem, m, r);

    (key, c)
}

/// # ML-KEM.Decaps
/// 
/// Expects a generic parameter to be provided, **`PARAMS`**, the ML-KEM parameters which should implement the trait [MlKemParams]
/// 
/// Takes in the cyphertext (from the other party) and the decapsulation key (from KeyGen earlier) as inputs, both of which are expected to already be deserialized and match the type signatures of [MlKemCyphertext] and [MlKemDecapsulationKey] respectively.
/// 
/// **Returns** the shared key (Party A's copy) if the decapsulation is successful (cyphertexts match), otherwise it returns a implicit rejection key.
pub fn decaps<PARAMS: MlKemParams>(c: MlKemCyphertext<{PARAMS::K}, {PARAMS::D_U}, {PARAMS::D_V}>, dk_mlkem: MlKemDecapsulationKey<{PARAMS::K}>) -> [u8; 32] where
    [(); PARAMS::K]: ,
    [(); 384 * PARAMS::K + 32]: ,
    [(); 32*(PARAMS::D_U * PARAMS::K + PARAMS::D_V)]: ,
    [(); 64 * PARAMS::ETA_1]: ,
    [(); 64 * PARAMS::ETA_2]: ,
    [(); 384 * PARAMS::K + 32]:
{
    let (dk, ek, hash, z) = dk_mlkem;

    let m = kpke::decrypt::<PARAMS>(dk, c.clone());

    let mut combined = [0u8; 64];

    combined[..32].copy_from_slice(m.serialize().as_raw_slice());
    combined[32..].copy_from_slice(&hash);

    let (key, rand) = crypt::g::<64>(&combined);

    let key_reject = crypt::j([&z, c.serialize().as_raw_slice()].concat());

    let c_prime = kpke::encrypt::<PARAMS>(ek, m, rand); // Should be same as encaps

    match (c.0 == c_prime.0) && (c.1 == c_prime.1) {
        true => key,
        false => key_reject
    }
}


mod tests {
    #[test]
    fn test_mlkem<>(){
        use super::*;
        type PARAMS = MlKem512;

        //ML-KEM.KeyGen
        let (ek, dk) = key_gen::<PARAMS>();

        let ek = ek.serialize();
        let dk = dk.serialize();

        //ML-KEM.Encaps
        let ek = MlKemEncapsulationKey::<{PARAMS::K}>::deserialize(&ek);
        
        let (key, c) = encaps::<PARAMS>(ek);

        let c = c.serialize();

        //ML-KEM.Decaps
        let dk = MlKemDecapsulationKey::<{PARAMS::K}>::deserialize(&dk);
        let c = MlKemCyphertext::<{PARAMS::K}, {PARAMS::D_U}, {PARAMS::D_V}>::deserialize(&c);

        let key_prime = decaps::<PARAMS>(c, dk);

        assert_eq!(key, key_prime);
    }
}